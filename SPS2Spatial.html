<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SPS Point Record Converter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Inter', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 40px;
            font-size: 2.5rem;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 700;
        }

        .upload-section {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            text-align: center;
            color: white;
        }

        .file-input {
            display: none;
        }

        .file-label {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            padding: 15px 30px;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid rgba(255, 255, 255, 0.3);
            font-size: 1.1rem;
            font-weight: 600;
            text-decoration: none;
        }

        .file-label:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        .files-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .file-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }

        .file-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2);
        }

        .file-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .file-name {
            font-weight: bold;
            font-size: 1.1rem;
            color: white;
        }

        .file-size {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .remove-file {
            background: rgba(255, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.3s ease;
        }

        .remove-file:hover {
            background: rgba(255, 0, 0, 0.9);
            transform: scale(1.1);
        }

        .output-name-group {
            margin-bottom: 15px;
        }

        .output-name-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .output-name-input {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            font-size: 0.95rem;
        }

        .file-status {
            margin-top: 10px;
            padding: 8px;
            border-radius: 5px;
            font-size: 0.9rem;
            text-align: center;
            font-weight: 500;
        }

        .status-ready { background: rgba(0, 255, 0, 0.2); }
        .status-processing { background: rgba(255, 255, 0, 0.2); }
        .status-completed { background: rgba(0, 255, 0, 0.3); }
        .status-error { background: rgba(255, 0, 0, 0.2); }

        .config-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .config-card {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            border-radius: 15px;
            padding: 25px;
            color: white;
        }

        .config-card h3 {
            margin-bottom: 15px;
            font-size: 1.3rem;
            text-align: center;
            font-weight: 600;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
        }

        input, select {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }

        input:focus, select:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.3);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .checkbox-group input[type="checkbox"] {
            width: auto;
            margin: 0;
        }

        .convert-section {
            text-align: center;
            margin-bottom: 30px;
        }

        .convert-btn {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            color: white;
            border: none;
            padding: 18px 40px;
            border-radius: 50px;
            font-size: 1.2rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .convert-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2);
        }

        .convert-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .results-section {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
            border-radius: 15px;
            padding: 30px;
            display: none;
            margin-bottom: 30px;
        }

        .results-title {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.5rem;
            color: #333;
            font-weight: 600;
        }

        .file-results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
        }

        .file-result-card {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .file-result-header {
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .download-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
        }

        .download-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            text-decoration: none;
            padding: 12px 15px;
            border-radius: 8px;
            font-weight: 600;
            text-align: center;
            transition: all 0.3s ease;
            display: block;
            font-size: 0.9rem;
        }

        .download-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        }

        .preview-section {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-top: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .preview-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            font-size: 0.9rem;
        }

        .preview-table th,
        .preview-table td {
            padding: 8px 12px;
            text-align: center;
            border-bottom: 1px solid #ddd;
        }

        .preview-table th {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            font-size: 0.85rem;
        }

        .status {
            padding: 15px;
            margin: 15px 0;
            border-radius: 8px;
            font-weight: 600;
            text-align: center;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .processing {
            animation: pulse 1.5s infinite;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            margin-top: 10px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #00ff00, #00cc00);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .file-points-count {
            font-size: 0.9rem;
            opacity: 0.9;
            margin-top: 5px;
        }

        .all-files-card {
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
            border: 3px solid #ff6b6b;
            position: relative;
            overflow: hidden;
        }

        .all-files-card::before {
            content: '⭐';
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 24px;
            animation: twinkle 2s infinite;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }

        .download-all-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            grid-column: 1 / -1;
            font-size: 1rem;
            padding: 15px;
            position: relative;
            overflow: hidden;
        }

        .download-all-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .download-all-btn:hover::before {
            left: 100%;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            .files-grid,
            .config-section,
            .file-results-grid {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🗺️SPS Point Converter</h1>
        
        <div class="upload-section">
            <h2>Upload SPS Point Files</h2>
            <p style="margin: 15px 0;">Select your .S or .R point files for conversion</p>
            <input type="file" id="fileInput" class="file-input" multiple accept=".S,.R,.s,.r">
            <label for="fileInput" class="file-label">📁 Choose Files</label>
            <div id="filesGrid" class="files-grid"></div>
        </div>

        <div class="config-section">
            <div class="config-card">
                <h3>🌍 Coordinate System</h3>
                <div class="form-group">
                    <label for="utmZone">UTM Zone:</label>
                    <select id="utmZone">
                        <option value="32">Zone 32N</option>
                        <option value="33">Zone 33N</option>
                        <option value="34">Zone 34N</option>
                        <option value="35">Zone 35N</option>
                        <option value="36">Zone 36N</option>
                        <option value="37">Zone 37N</option>
                        <option value="38">Zone 38N</option>
                        <option value="39">Zone 39N</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="datum">Datum:</label>
                    <select id="datum">
                        <option value="WGS84">WGS84</option>
                        <option value="ED50">ED50</option>
                        <option value="NAD83">NAD83</option>
                    </select>
                </div>
            </div>

            <div class="config-card">
                <h3>📊 Export Options</h3>
                <div class="checkbox-group">
                    <input type="checkbox" id="exportCSV" checked>
                    <label for="exportCSV">CSV Format</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="exportGeoJSON" checked>
                    <label for="exportGeoJSON">GeoJSON Format</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="exportKML" checked>
                    <label for="exportKML">KML Format</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="exportShapefile" checked>
                    <label for="exportShapefile">Shapefile Format</label>
                </div>
            </div>

            <div class="config-card">
                <h3>⚙️ Additional Settings</h3>
                <div class="checkbox-group">
                    <input type="checkbox" id="showPreview" checked>
                    <label for="showPreview">Show Data Preview</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="zipAllFiles">
                    <label for="zipAllFiles">Compress All Files into One Archive</label>
                </div>
            </div>
        </div>

        <div class="convert-section">
            <button id="convertBtn" class="convert-btn">🚀 Convert Files</button>
            <div id="globalProgress" style="display: none; margin-top: 15px;">
                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill" style="width: 0%"></div>
                </div>
                <p id="progressText" style="margin-top: 10px; color: #333;">Converting...</p>
            </div>
        </div>

        <div id="resultsSection" class="results-section">
            <h3 class="results-title">📥 Download Converted Files</h3>
            <div id="fileResultsGrid" class="file-results-grid"></div>
        </div>

        <div id="previewSection" class="preview-section" style="display: none;">
            <h3>👀 Data Preview</h3>
            <div id="previewContent"></div>
        </div>

        <div id="status"></div>
    </div>

    <script>
        let uploadedFiles = [];
        let fileDataMap = {};
        let convertedFiles = {};

        // Proj4 definitions
        const projDefs = {
            'WGS84': '+proj=longlat +datum=WGS84 +no_defs',
            'ED50': '+proj=longlat +ellps=intl +towgs84=-87,-98,-121,0,0,0,0 +no_defs',
            'NAD83': '+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs'
        };

        document.getElementById('fileInput').addEventListener('change', handleFileUpload);
        document.getElementById('convertBtn').addEventListener('click', convertFiles);

        function handleFileUpload(event) {
            const newFiles = Array.from(event.target.files);
            
            // Add new files, avoid duplicates
            newFiles.forEach(file => {
                if (!uploadedFiles.find(f => f.name === file.name && f.size === file.size)) {
                    uploadedFiles.push(file);
                }
            });
            
            displayFileCards();
        }

        function displayFileCards() {
            const filesGrid = document.getElementById('filesGrid');
            
            if (uploadedFiles.length === 0) {
                filesGrid.innerHTML = '';
                return;
            }

            filesGrid.innerHTML = uploadedFiles.map((file, index) => `
                <div class="file-card" data-index="${index}">
                    <div class="file-header">
                        <div>
                            <div class="file-name">📄 ${file.name}</div>
                            <div class="file-size">${(file.size / 1024).toFixed(1)} KB</div>
                        </div>
                        <button class="remove-file" onclick="removeFile(${index})">×</button>
                    </div>
                    <div class="output-name-group">
                        <label>Output File Name:</label>
                        <input type="text" class="output-name-input" 
                               value="${file.name.replace(/\.[^/.]+$/, '')}"
                               placeholder="Enter converted file name"
                               id="outputName_${index}">
                    </div>
                    <div class="file-status status-ready" id="fileStatus_${index}">
                        Ready for conversion
                    </div>
                    <div class="file-points-count" id="pointsCount_${index}"></div>
                </div>
            `).join('');
        }

        function removeFile(index) {
            uploadedFiles.splice(index, 1);
            delete fileDataMap[`file_${index}`];
            displayFileCards();
            
            if (uploadedFiles.length === 0) {
                document.getElementById('resultsSection').style.display = 'none';
                document.getElementById('previewSection').style.display = 'none';
            }
        }

        function showStatus(message, type = 'success') {
            const statusDiv = document.getElementById('status');
            statusDiv.innerHTML = `<div class="status ${type}">${message}</div>`;
            setTimeout(() => statusDiv.innerHTML = '', 5000);
        }

        function updateFileStatus(index, status, message, pointsCount = null) {
            const statusElement = document.getElementById(`fileStatus_${index}`);
            const pointsElement = document.getElementById(`pointsCount_${index}`);
            
            if (statusElement) {
                statusElement.className = `file-status status-${status}`;
                statusElement.textContent = message;
            }
            
            if (pointsElement && pointsCount !== null) {
                pointsElement.textContent = `Points: ${pointsCount}`;
            }
        }

        function updateGlobalProgress(current, total, message) {
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            const globalProgress = document.getElementById('globalProgress');
            
            if (total > 1) {
                globalProgress.style.display = 'block';
                const percentage = (current / total) * 100;
                progressFill.style.width = `${percentage}%`;
                progressText.textContent = `${message} (${current}/${total})`;
            } else {
                globalProgress.style.display = 'none';
            }
        }

        async function parseSPSFile(file, index) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const content = e.target.result;
                        const lines = content.split('\n');
                        const points = [];

                        lines.forEach((line) => {
                            if (line.trim() && (line.startsWith('S') || line.startsWith('R'))) {
                                const parts = line.trim().split(/\s+/);
                                if (parts.length >= 7) {
                                    const easting = parseFloat(parts[4]);
                                    const northing = parseFloat(parts[5]);
                                    const elevation = parseFloat(parts[6]);
                                    
                                    if (!isNaN(easting) && !isNaN(northing) && !isNaN(elevation)) {
                                        points.push({
                                            type: parts[0],
                                            line: parseFloat(parts[1]) || 0,
                                            point: parseFloat(parts[2]) || 0,
                                            index: parseInt(parts[3]) || 0,
                                            easting: easting,
                                            northing: northing,
                                            elevation: elevation,
                                            filename: file.name
                                        });
                                    }
                                }
                            }
                        });

                        updateFileStatus(index, 'completed', 'File parsed successfully', points.length);
                        resolve(points);
                    } catch (error) {
                        updateFileStatus(index, 'error', `Parse error: ${error.message}`);
                        reject(error);
                    }
                };
                reader.onerror = () => {
                    const errorMsg = 'Failed to read file';
                    updateFileStatus(index, 'error', errorMsg);
                    reject(new Error(errorMsg));
                };
                reader.readAsText(file);
            });
        }

        function convertUTMToLatLon(easting, northing, zone, datum) {
            const utmProj = `+proj=utm +zone=${zone} +datum=${datum} +units=m +no_defs`;
            const wgs84Proj = projDefs[datum];
            
            try {
                const result = proj4(utmProj, wgs84Proj, [easting, northing]);
                return { lon: result[0], lat: result[1] };
            } catch (error) {
                console.error('Projection error:', error);
                return { lon: easting, lat: northing };
            }
        }

        function generateCSV(data) {
            const headers = ['Type', 'Line', 'Point', 'Index', 'Easting', 'Northing', 'Elevation', 'Longitude', 'Latitude'];
            const csvContent = [
                headers.join(','),
                ...data.map(point => [
                    point.type, point.line, point.point, point.index,
                    point.easting, point.northing, point.elevation,
                    point.longitude, point.latitude
                ].join(','))
            ].join('\n');

            return new Blob([csvContent], { type: 'text/csv;charset=utf-8' });
        }

        function generateGeoJSON(data) {
            const features = data.map(point => ({
                type: 'Feature',
                geometry: {
                    type: 'Point',
                    coordinates: [point.longitude, point.latitude, point.elevation]
                },
                properties: {
                    type: point.type,
                    line: point.line,
                    point: point.point,
                    index: point.index,
                    easting: point.easting,
                    northing: point.northing,
                    elevation: point.elevation
                }
            }));

            const geojson = {
                type: 'FeatureCollection',
                features: features
            };

            return new Blob([JSON.stringify(geojson, null, 2)], { type: 'application/json' });
        }

        function generateKML(data) {
            let kml = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>SPS Points</name>
    <description>Converted SPS Point Records</description>
    <Style id="shotpoint">
      <IconStyle>
        <Icon>
          <href>http://maps.google.com/mapfiles/kml/shapes/placemark_circle.png</href>
        </Icon>
      </IconStyle>
    </Style>
    <Style id="receiver">
      <IconStyle>
        <Icon>
          <href>http://maps.google.com/mapfiles/kml/shapes/placemark_square.png</href>
        </Icon>
      </IconStyle>
    </Style>`;

            data.forEach(point => {
                kml += `
    <Placemark>
      <name>${point.type}-${point.line}-${point.point}</name>
      <description>
        Type: ${point.type}
        Line: ${point.line}
        Point: ${point.point}
        Index: ${point.index}
        UTM Easting: ${point.easting}
        UTM Northing: ${point.northing}
        Elevation: ${point.elevation}
      </description>
      <styleUrl>#${point.type === 'S' ? 'shotpoint' : 'receiver'}</styleUrl>
      <Point>
        <coordinates>${point.longitude},${point.latitude},${point.elevation}</coordinates>
      </Point>
    </Placemark>`;
            });

            kml += `
  </Document>
</kml>`;

            return new Blob([kml], { type: 'application/vnd.google-earth.kml+xml' });
        }

        async function generateShapefile(data) {
            // Generate DBF, SHP, and PRJ files
            function generateDBF(data) {
                if (data.length === 0) return new Uint8Array(32);

                const fields = [
                    { name: 'TYPE', type: 'C', length: 1 },
                    { name: 'LINE', type: 'N', length: 10, decimals: 2 },
                    { name: 'POINT', type: 'N', length: 10, decimals: 2 },
                    { name: 'INDEX', type: 'N', length: 5 },
                    { name: 'EASTING', type: 'N', length: 12, decimals: 2 },
                    { name: 'NORTHING', type: 'N', length: 12, decimals: 2 },
                    { name: 'ELEVATION', type: 'N', length: 10, decimals: 2 },
                    { name: 'LONGITUDE', type: 'N', length: 12, decimals: 6 },
                    { name: 'LATITUDE', type: 'N', length: 12, decimals: 6 }
                ];

                const recordLength = fields.reduce((sum, f) => sum + f.length, 0) + 1;
                const headerLength = 32 + fields.length * 32 + 1;
                const totalLength = headerLength + data.length * recordLength;
                
                const buffer = new ArrayBuffer(totalLength);
                const view = new DataView(buffer);
                const encoder = new TextEncoder();

                // Header
                view.setUint8(0, 0x03);
                const now = new Date();
                view.setUint8(1, now.getFullYear() - 1900);
                view.setUint8(2, now.getMonth() + 1);
                view.setUint8(3, now.getDate());
                view.setUint32(4, data.length, true);
                view.setUint16(8, headerLength, true);
                view.setUint16(10, recordLength, true);

                // Field descriptors
                let offset = 32;
                fields.forEach((field, i) => {
                    if (offset + 32 > buffer.byteLength) return;
                    
                    const nameBytes = encoder.encode(field.name.padEnd(11, '\0').substring(0, 11));
                    for (let j = 0; j < 11; j++) {
                        view.setUint8(offset + j, nameBytes[j] || 0);
                    }
                    view.setUint8(offset + 11, field.type.charCodeAt(0));
                    view.setUint8(offset + 16, field.length);
                    if (field.decimals) view.setUint8(offset + 17, field.decimals);
                    offset += 32;
                });

                if (offset < buffer.byteLength) {
                    view.setUint8(offset++, 0x0D);
                }

                // Records
                data.forEach(point => {
                    if (offset >= buffer.byteLength) return;
                    
                    view.setUint8(offset++, 0x20);
                    
                    const values = [
                        (point.type || '').toString(),
                        (point.line || 0).toFixed(2),
                        (point.point || 0).toFixed(2),
                        (point.index || 0).toString(),
                        (point.easting || 0).toFixed(2),
                        (point.northing || 0).toFixed(2),
                        (point.elevation || 0).toFixed(2),
                        (point.longitude || 0).toFixed(6),
                        (point.latitude || 0).toFixed(6)
                    ];

                    values.forEach((value, i) => {
                        if (offset + fields[i].length > buffer.byteLength) return;
                        
                        const padded = value.toString().padEnd(fields[i].length, ' ').substring(0, fields[i].length);
                        const bytes = encoder.encode(padded);
                        for (let j = 0; j < fields[i].length; j++) {
                            if (offset < buffer.byteLength) {
                                view.setUint8(offset++, bytes[j] || 32);
                            }
                        }
                    });
                });

                return new Uint8Array(buffer);
            }

            function generateSHP(data) {
                if (data.length === 0) return new Uint8Array(100);

                const recordSize = 28;
                const totalSize = 100 + data.length * recordSize;
                const buffer = new ArrayBuffer(totalSize);
                const view = new DataView(buffer);

                // Header
                view.setUint32(0, 9994, false);
                view.setUint32(24, totalSize / 2, false);
                view.setUint32(28, 1000, true);
                view.setUint32(32, 1, true);

                const validPoints = data.filter(p => 
                    p.longitude && p.latitude && 
                    !isNaN(p.longitude) && !isNaN(p.latitude) &&
                    isFinite(p.longitude) && isFinite(p.latitude)
                );
                
                if (validPoints.length === 0) {
                    view.setFloat64(36, 0, true);
                    view.setFloat64(44, 0, true);
                    view.setFloat64(52, 0, true);
                    view.setFloat64(60, 0, true);
                } else {
                    const lons = validPoints.map(p => p.longitude);
                    const lats = validPoints.map(p => p.latitude);
                    view.setFloat64(36, Math.min(...lons), true);
                    view.setFloat64(44, Math.min(...lats), true);
                    view.setFloat64(52, Math.max(...lons), true);
                    view.setFloat64(60, Math.max(...lats), true);
                }

                let offset = 100;
                data.forEach((point, i) => {
                    if (offset + recordSize > buffer.byteLength) return;
                    
                    view.setUint32(offset, i + 1, false);
                    view.setUint32(offset + 4, 10, false);
                    view.setUint32(offset + 8, 1, true);
                    
                    const lon = (point.longitude && isFinite(point.longitude)) ? point.longitude : 0;
                    const lat = (point.latitude && isFinite(point.latitude)) ? point.latitude : 0;
                    
                    view.setFloat64(offset + 12, lon, true);
                    view.setFloat64(offset + 20, lat, true);
                    offset += recordSize;
                });

                return new Uint8Array(buffer);
            }

            function generatePRJ() {
                return 'GEOGCS["WGS 84",DATUM["WGS_1984",SPHEROID["WGS 84",6378137,298.257223563,AUTHORITY["EPSG","7030"]],AUTHORITY["EPSG","6326"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4326"]]';
            }

            const zip = new JSZip();
            zip.file('points.shp', generateSHP(data));
            zip.file('points.dbf', generateDBF(data));
            zip.file('points.prj', generatePRJ());

            return zip.generateAsync({ type: 'blob' });
        }

        async function convertFiles() {
            if (uploadedFiles.length === 0) {
                showStatus('Please select files first!', 'error');
                return;
            }

            const convertBtn = document.getElementById('convertBtn');
            convertBtn.disabled = true;
            convertBtn.classList.add('processing');
            convertBtn.innerHTML = '⏳ Converting...';

            try {
                fileDataMap = {};
                convertedFiles = {};
                const utmZone = document.getElementById('utmZone').value;
                const datum = document.getElementById('datum').value;

                let totalPoints = 0;
                let allPreviewData = [];

                // Process each file individually
                for (let i = 0; i < uploadedFiles.length; i++) {
                    const file = uploadedFiles[i];
                    updateGlobalProgress(i, uploadedFiles.length, `Processing file: ${file.name}`);
                    updateFileStatus(i, 'processing', 'Parsing file...');
                    
                    try {
                        const points = await parseSPSFile(file, i);
                        
                        // Convert coordinates
                        points.forEach(point => {
                            const latLon = convertUTMToLatLon(point.easting, point.northing, utmZone, datum);
                            point.longitude = latLon.lon;
                            point.latitude = latLon.lat;
                        });

                        const fileKey = `file_${i}`;
                        fileDataMap[fileKey] = {
                            originalFile: file,
                            points: points,
                            outputName: document.getElementById(`outputName_${i}`).value || file.name.replace(/\.[^/.]+$/, ''),
                            index: i
                        };

                        totalPoints += points.length;
                        allPreviewData.push(...points.slice(0, 3)); // Add first 3 points from each file to preview
                        
                        updateFileStatus(i, 'completed', 'Conversion successful', points.length);
                    } catch (error) {
                        updateFileStatus(i, 'error', `Error: ${error.message}`);
                        console.error(`Error processing file ${file.name}:`, error);
                    }
                }

                updateGlobalProgress(uploadedFiles.length, uploadedFiles.length, 'Conversion complete');

                showStatus(`Successfully converted ${Object.keys(fileDataMap).length} files with ${totalPoints} total points!`);
                
                // Show preview if enabled
                if (document.getElementById('showPreview').checked && allPreviewData.length > 0) {
                    showPreview(allPreviewData);
                }

                // Generate downloads for each file
                await generateAllDownloads();
                
                document.getElementById('resultsSection').style.display = 'block';

                // Hide progress after completion
                setTimeout(() => {
                    document.getElementById('globalProgress').style.display = 'none';
                }, 2000);

            } catch (error) {
                console.error('Conversion error:', error);
                showStatus(`Error during conversion: ${error.message}`, 'error');
            } finally {
                convertBtn.disabled = false;
                convertBtn.classList.remove('processing');
                convertBtn.innerHTML = '🚀 Convert Files';
            }
        }

        function showPreview(data) {
            const previewSection = document.getElementById('previewSection');
            const previewContent = document.getElementById('previewContent');
            
            let html = `<p>Data Preview (showing ${data.length} points out of ${Object.values(fileDataMap).reduce((sum, file) => sum + file.points.length, 0)} total points):</p>`;
            html += '<table class="preview-table">';
            html += '<tr><th>Type</th><th>Line</th><th>Point</th><th>Easting</th><th>Northing</th><th>Longitude</th><th>Latitude</th><th>File</th></tr>';
            
            data.forEach(point => {
                html += `<tr>
                    <td>${point.type}</td>
                    <td>${point.line}</td>
                    <td>${point.point}</td>
                    <td>${point.easting.toFixed(2)}</td>
                    <td>${point.northing.toFixed(2)}</td>
                    <td>${point.longitude.toFixed(6)}</td>
                    <td>${point.latitude.toFixed(6)}</td>
                    <td>${point.filename}</td>
                </tr>`;
            });
            
            html += '</table>';
            previewContent.innerHTML = html;
            previewSection.style.display = 'block';
        }

        async function generateAllDownloads() {
            const fileResultsGrid = document.getElementById('fileResultsGrid');
            fileResultsGrid.innerHTML = '';

            const zipAllFiles = document.getElementById('zipAllFiles').checked;
            let allFilesZip = null;
            
            if (zipAllFiles) {
                allFilesZip = new JSZip();
            }

            for (const [fileKey, fileData] of Object.entries(fileDataMap)) {
                const { points, outputName, originalFile } = fileData;
                
                let downloadHtml = `
                    <div class="file-result-card">
                        <div class="file-result-header">
                            📄 ${originalFile.name}
                            <br><small>Output name: ${outputName}</small>
                            <br><small>Points: ${points.length}</small>
                        </div>
                        <div class="download-grid">`;

                // Generate individual format files
                if (document.getElementById('exportCSV').checked) {
                    const csvBlob = generateCSV(points);
                    const csvUrl = URL.createObjectURL(csvBlob);
                    const csvFileName = `${outputName}.csv`;
                    downloadHtml += `<a href="${csvUrl}" download="${csvFileName}" class="download-btn">📊 CSV</a>`;
                    
                    if (zipAllFiles) allFilesZip.file(csvFileName, csvBlob);
                }

                if (document.getElementById('exportGeoJSON').checked) {
                    const geojsonBlob = generateGeoJSON(points);
                    const geojsonUrl = URL.createObjectURL(geojsonBlob);
                    const geojsonFileName = `${outputName}.geojson`;
                    downloadHtml += `<a href="${geojsonUrl}" download="${geojsonFileName}" class="download-btn">🗺️ GeoJSON</a>`;
                    
                    if (zipAllFiles) allFilesZip.file(geojsonFileName, geojsonBlob);
                }

                if (document.getElementById('exportKML').checked) {
                    const kmlBlob = generateKML(points);
                    const kmlUrl = URL.createObjectURL(kmlBlob);
                    const kmlFileName = `${outputName}.kml`;
                    downloadHtml += `<a href="${kmlUrl}" download="${kmlFileName}" class="download-btn">🌍 KML</a>`;
                    
                    if (zipAllFiles) allFilesZip.file(kmlFileName, kmlBlob);
                }

                if (document.getElementById('exportShapefile').checked) {
                    const shapefileBlob = await generateShapefile(points);
                    const shapefileUrl = URL.createObjectURL(shapefileBlob);
                    const shapefileName = `${outputName}_shapefile.zip`;
                    downloadHtml += `<a href="${shapefileUrl}" download="${shapefileName}" class="download-btn">📁 Shapefile</a>`;
                    
                    if (zipAllFiles) allFilesZip.file(shapefileName, shapefileBlob);
                }

                downloadHtml += '</div></div>';
                fileResultsGrid.innerHTML += downloadHtml;
            }

            // Add download all option if enabled
            if (zipAllFiles && allFilesZip) {
                const allFilesBlob = await allFilesZip.generateAsync({ type: 'blob' });
                const allFilesUrl = URL.createObjectURL(allFilesBlob);
                
                fileResultsGrid.innerHTML += `
                    <div class="file-result-card all-files-card">
                        <div class="file-result-header" style="color: #333;">
                            📦 Download All Files
                            <br><small>Archive containing all converted files</small>
                        </div>
                        <div class="download-grid">
                            <a href="${allFilesUrl}" download="all_converted_files.zip" 
                               class="download-btn download-all-btn">
                               🎯 Download All
                            </a>
                        </div>
                    </div>`;
            }
        }

        // Cleanup URLs when page unloads to prevent memory leaks
        window.addEventListener('beforeunload', () => {
            // Revoke all created object URLs
            document.querySelectorAll('a[href^="blob:"]').forEach(link => {
                URL.revokeObjectURL(link.href);
            });
        });
    </script>
</body>
</html>