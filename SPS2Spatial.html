<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SPS Point Converter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        :root {
            --primary-color: #2563eb;
            --primary-dark: #1d4ed8;
            --secondary-color: #64748b;
            --accent-color: #06b6d4;
            --success-color: #10b981;
            --warning-color: #f59e0b;
            --error-color: #ef4444;
            --background-light: #f8fafc;
            --background-white: #ffffff;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --border-color: #e2e8f0;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
            --radius-sm: 0.375rem;
            --radius-md: 0.5rem;
            --radius-lg: 0.75rem;
            --radius-xl: 1rem;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, var(--background-light) 0%, #e0e7ff 100%);
            min-height: 100vh;
            color: var(--text-primary);
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        /* Header */
        .header {
            text-align: center;
            margin-bottom: 3rem;
            padding: 2rem 0;
        }

        .header h1 {
            font-size: 3rem;
            font-weight: 800;
            background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 1rem;
            letter-spacing: -0.025em;
        }

        .header p {
            font-size: 1.25rem;
            color: var(--text-secondary);
            max-width: 600px;
            margin: 0 auto;
        }

        /* Card Component */
        .card {
            background: var(--background-white);
            border-radius: var(--radius-xl);
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .card:hover {
            box-shadow: var(--shadow-xl);
            transform: translateY(-2px);
        }

        .card-header {
            padding: 1.5rem 2rem;
            border-bottom: 1px solid var(--border-color);
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
        }

        .card-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .card-content {
            padding: 2rem;
        }

        /* Upload Section */
        .upload-section {
            margin-bottom: 2rem;
        }

        .upload-area {
            border: 2px dashed var(--border-color);
            border-radius: var(--radius-lg);
            padding: 3rem 2rem;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .upload-area:hover,
        .upload-area.drag-over {
            border-color: var(--primary-color);
            background: linear-gradient(135deg, rgba(37, 99, 235, 0.05) 0%, rgba(6, 182, 212, 0.05) 100%);
            transform: scale(1.02);
        }

        .upload-area.drag-over {
            border-style: solid;
            background: linear-gradient(135deg, rgba(37, 99, 235, 0.1) 0%, rgba(6, 182, 212, 0.1) 100%);
        }

        .upload-icon {
            font-size: 3rem;
            color: var(--primary-color);
            margin-bottom: 1rem;
            transition: all 0.3s ease;
        }

        .upload-area:hover .upload-icon {
            transform: scale(1.1);
        }

        .upload-text {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }

        .upload-subtext {
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        .file-input {
            display: none;
        }

        /* File Grid */
        .files-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
        }

        .file-card {
            background: var(--background-white);
            border-radius: var(--radius-lg);
            border: 1px solid var(--border-color);
            padding: 1.5rem;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .file-card:hover {
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
        }

        .file-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1rem;
        }

        .file-info {
            flex: 1;
        }

        .file-name {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.25rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .file-size {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remove-btn {
            background: var(--error-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 2rem;
            height: 2rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            font-size: 0.875rem;
        }

        .remove-btn:hover {
            background: #dc2626;
            transform: scale(1.1);
        }

        .output-name-group {
            margin-bottom: 1rem;
        }

        .output-name-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--text-primary);
        }

        .output-name-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            font-size: 0.875rem;
            transition: all 0.3s ease;
        }

        .output-name-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .file-status {
            padding: 0.5rem 1rem;
            border-radius: var(--radius-md);
            font-size: 0.875rem;
            font-weight: 500;
            text-align: center;
            margin-top: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .status-ready {
            background: rgba(16, 185, 129, 0.1);
            color: var(--success-color);
            border: 1px solid rgba(16, 185, 129, 0.2);
        }

        .status-processing {
            background: rgba(245, 158, 11, 0.1);
            color: var(--warning-color);
            border: 1px solid rgba(245, 158, 11, 0.2);
        }

        .status-completed {
            background: rgba(16, 185, 129, 0.1);
            color: var(--success-color);
            border: 1px solid rgba(16, 185, 129, 0.2);
        }

        .status-error {
            background: rgba(239, 68, 68, 0.1);
            color: var(--error-color);
            border: 1px solid rgba(239, 68, 68, 0.2);
        }

        /* Configuration Section */
        .config-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-group:last-child {
            margin-bottom: 0;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--text-primary);
        }

        input, select {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            font-size: 1rem;
            transition: all 0.3s ease;
            background: var(--background-white);
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
            padding: 0.75rem;
            border-radius: var(--radius-md);
            transition: all 0.3s ease;
        }

        .checkbox-group:hover {
            background: rgba(37, 99, 235, 0.05);
        }

        .checkbox-group input[type="checkbox"] {
            width: auto;
            margin: 0;
            accent-color: var(--primary-color);
        }

        .checkbox-group label {
            margin: 0;
            cursor: pointer;
            flex: 1;
        }

        /* Convert Section */
        .convert-section {
            text-align: center;
            margin-bottom: 2rem;
        }

        .convert-btn {
            background: linear-gradient(135deg, var(--primary-color), var(--primary-dark));
            color: white;
            border: none;
            padding: 1rem 2.5rem;
            border-radius: var(--radius-lg);
            font-size: 1.125rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.75rem;
            position: relative;
            overflow: hidden;
        }

        .convert-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .convert-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .convert-btn.processing {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* Progress Bar */
        .progress-container {
            margin-top: 1.5rem;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 0.5rem;
            background: var(--border-color);
            border-radius: var(--radius-sm);
            overflow: hidden;
            margin-bottom: 1rem;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
            border-radius: var(--radius-sm);
            transition: width 0.3s ease;
            position: relative;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .progress-text {
            color: var(--text-secondary);
            font-size: 0.875rem;
            text-align: center;
        }

        /* Results Section */
        .results-section {
            display: none;
            margin-bottom: 2rem;
        }

        .file-results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: 1.5rem;
        }

        .file-result-card {
            background: var(--background-white);
            border-radius: var(--radius-lg);
            border: 1px solid var(--border-color);
            padding: 1.5rem;
            box-shadow: var(--shadow-md);
        }

        .file-result-header {
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text-primary);
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .download-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 0.75rem;
        }

        .download-btn {
            background: linear-gradient(135deg, var(--primary-color), var(--primary-dark));
            color: white;
            text-decoration: none;
            padding: 0.75rem 1rem;
            border-radius: var(--radius-md);
            font-weight: 500;
            text-align: center;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            font-size: 0.875rem;
        }

        .download-btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .download-all-btn {
            background: linear-gradient(135deg, var(--success-color), #059669);
            grid-column: 1 / -1;
            font-size: 1rem;
            padding: 1rem;
        }

        /* Preview Section */
        .preview-section {
            display: none;
            margin-bottom: 2rem;
        }

        .preview-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            font-size: 0.875rem;
            border-radius: var(--radius-lg);
            overflow: hidden;
            box-shadow: var(--shadow-sm);
        }

        .preview-table th,
        .preview-table td {
            padding: 0.75rem;
            text-align: center;
            border-bottom: 1px solid var(--border-color);
        }

        .preview-table th {
            background: linear-gradient(135deg, var(--primary-color), var(--primary-dark));
            color: white;
            font-weight: 600;
            font-size: 0.8rem;
        }

        .preview-table tr:hover {
            background: rgba(37, 99, 235, 0.05);
        }

        /* Status Messages */
        .status {
            padding: 1rem 1.5rem;
            margin: 1rem 0;
            border-radius: var(--radius-lg);
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .status.success {
            background: rgba(16, 185, 129, 0.1);
            color: var(--success-color);
            border: 1px solid rgba(16, 185, 129, 0.2);
        }

        .status.error {
            background: rgba(239, 68, 68, 0.1);
            color: var(--error-color);
            border: 1px solid rgba(239, 68, 68, 0.2);
        }

        .status.info {
            background: rgba(6, 182, 212, 0.1);
            color: var(--accent-color);
            border: 1px solid rgba(6, 182, 212, 0.2);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .files-grid,
            .config-section,
            .file-results-grid {
                grid-template-columns: 1fr;
            }
            
            .card-content {
                padding: 1.5rem;
            }
            
            .upload-area {
                padding: 2rem 1rem;
            }
        }

        /* Loading Animation */
        .loading-spinner {
            display: inline-block;
            width: 1rem;
            height: 1rem;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Tooltip */
        .tooltip {
            position: relative;
            cursor: help;
        }

        .tooltip::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--text-primary);
            color: white;
            padding: 0.5rem;
            border-radius: var(--radius-sm);
            font-size: 0.75rem;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 1000;
        }

        .tooltip:hover::after {
            opacity: 1;
        }

        /* Animations */
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .slide-up {
            animation: slideUp 0.3s ease-out;
        }

        @keyframes slideUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1><i class="fas fa-map-marked-alt"></i> SPS Point Converter </h1>
            <p>An advanced tool to convert SPS point files to multiple spatial formats with ease and high accuracy.</p>
        </div>
        
        <div class="card upload-section">
            <div class="card-header">
                <h2 class="card-title">
                    <i class="fas fa-cloud-upload-alt"></i>
                    Upload Files
                </h2>
            </div>
            <div class="card-content">
                <div class="upload-area" id="uploadArea">
                    <i class="fas fa-file-upload upload-icon"></i>
                    <div class="upload-text">Drag & Drop SPS Files Here</div>
                    <div class="upload-subtext">Or click to choose files (.S, .R)</div>
                    <input type="file" id="fileInput" class="file-input" multiple accept=".S,.R,.s,.r">
                </div>
                <div id="filesGrid" class="files-grid"></div>
            </div>
        </div>

        <div class="config-section">
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">
                        <i class="fas fa-globe"></i>
                        Coordinate System
                    </h3>
                </div>
                <div class="card-content">
                    <div class="form-group">
                        <label for="utmZone">UTM Zone:</label>
                        <select id="utmZone">
                            <option value="32">Zone 32N</option>
                            <option value="33">Zone 33N</option>
                            <option value="34">Zone 34N</option>
                            <option value="35">Zone 35N</option>
                            <option value="36">Zone 36N</option>
                            <option value="37">Zone 37N</option>
                            <option value="38">Zone 38N</option>
                            <option value="39">Zone 39N</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="datum">Datum:</label>
                        <select id="datum">
                            <option value="WGS84">WGS84</option>
                            <option value="ED50">ED50</option>
                            <option value="NAD83">NAD83</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">
                        <i class="fas fa-download"></i>
                        Export Options
                    </h3>
                </div>
                <div class="card-content">
                    <div class="checkbox-group">
                        <input type="checkbox" id="exportCSV" checked>
                        <label for="exportCSV">CSV Format</label>
                        <i class="fas fa-info-circle tooltip" data-tooltip="Simple tabular file"></i>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="exportGeoJSON" checked>
                        <label for="exportGeoJSON">GeoJSON Format</label>
                        <i class="fas fa-info-circle tooltip" data-tooltip="Geospatial format for the web"></i>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="exportKML" checked>
                        <label for="exportKML">KML Format</label>
                        <i class="fas fa-info-circle tooltip" data-tooltip="Compatible with Google Earth"></i>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="exportShapefile" checked>
                        <label for="exportShapefile">Shapefile Format</label>
                        <i class="fas fa-info-circle tooltip" data-tooltip="Standard GIS format"></i>
                    </div>
                </div>
            </div>

            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">
                        <i class="fas fa-cog"></i>
                        Additional Settings
                    </h3>
                </div>
                <div class="card-content">
                    <div class="checkbox-group">
                        <input type="checkbox" id="showPreview" checked>
                        <label for="showPreview">Show Data Preview</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="zipAllFiles">
                        <label for="zipAllFiles">Compress All Files into One Archive</label>
                    </div>
                </div>
            </div>
        </div>

        <div class="convert-section">
            <button id="convertBtn" class="convert-btn">
                <i class="fas fa-rocket"></i>
                Convert Files
            </button>
            <div id="progressContainer" class="progress-container">
                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill" style="width: 0%"></div>
                </div>
                <p id="progressText" class="progress-text">Converting...</p>
            </div>
        </div>

        <div id="resultsSection" class="results-section card">
            <div class="card-header">
                <h3 class="card-title">
                    <i class="fas fa-download"></i>
                    Download Converted Files
                </h3>
            </div>
            <div class="card-content">
                <div id="fileResultsGrid" class="file-results-grid"></div>
            </div>
        </div>

        <div id="previewSection" class="preview-section card">
            <div class="card-header">
                <h3 class="card-title">
                    <i class="fas fa-eye"></i>
                    Data Preview
                </h3>
            </div>
            <div class="card-content">
                <div id="previewContent"></div>
            </div>
        </div>

        <div id="status"></div>
    </div>

    <script>
        // Global variables
        let uploadedFiles = [];
        let fileDataMap = {};
        let convertedFiles = {};

        // Proj4 definitions
        const projDefs = {
            'WGS84': '+proj=longlat +datum=WGS84 +no_defs',
            'ED50': '+proj=longlat +ellps=intl +towgs84=-87,-98,-121,0,0,0,0 +no_defs',
            'NAD83': '+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs'
        };

        // Initialize event listeners
        document.addEventListener('DOMContentLoaded', function() {
            initializeEventListeners();
        });

        function initializeEventListeners() {
            const fileInput = document.getElementById('fileInput');
            const uploadArea = document.getElementById('uploadArea');
            const convertBtn = document.getElementById('convertBtn');

            // File input change
            fileInput.addEventListener('change', handleFileUpload);

            // Upload area click
            uploadArea.addEventListener('click', () => fileInput.click());

            // Drag and drop functionality
            uploadArea.addEventListener('dragover', handleDragOver);
            uploadArea.addEventListener('dragleave', handleDragLeave);
            uploadArea.addEventListener('drop', handleDrop);

            // Convert button
            convertBtn.addEventListener('click', convertFiles);

            // Prevent default drag behaviors
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                uploadArea.addEventListener(eventName, preventDefaults, false);
                document.body.addEventListener(eventName, preventDefaults, false);
            });
        }

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function handleDragOver(e) {
            document.getElementById('uploadArea').classList.add('drag-over');
        }

        function handleDragLeave(e) {
            document.getElementById('uploadArea').classList.remove('drag-over');
        }

        function handleDrop(e) {
            const uploadArea = document.getElementById('uploadArea');
            uploadArea.classList.remove('drag-over');
            
            const files = Array.from(e.dataTransfer.files);
            addFiles(files);
        }

        function handleFileUpload(event) {
            const files = Array.from(event.target.files);
            addFiles(files);
        }

        function addFiles(newFiles) {
            // Filter and add new files, avoid duplicates
            newFiles.forEach(file => {
                if (file.name.match(/\.(S|R|s|r)$/)) {
                    if (!uploadedFiles.find(f => f.name === file.name && f.size === file.size)) {
                        uploadedFiles.push(file);
                    }
                }
            });
            
            displayFileCards();
            
            // Add animation to new cards
            setTimeout(() => {
                document.querySelectorAll('.file-card').forEach(card => {
                    card.classList.add('slide-up');
                });
            }, 100);
        }

        function displayFileCards() {
            const filesGrid = document.getElementById('filesGrid');
            
            if (uploadedFiles.length === 0) {
                filesGrid.innerHTML = '';
                return;
            }

            filesGrid.innerHTML = uploadedFiles.map((file, index) => `
                <div class="file-card" data-index="${index}">
                    <div class="file-header">
                        <div class="file-info">
                            <div class="file-name">
                                <i class="fas fa-file-alt"></i>
                                ${file.name}
                            </div>
                            <div class="file-size">${(file.size / 1024).toFixed(1)} KB</div>
                        </div>
                        <button class="remove-btn" onclick="removeFile(${index})">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="output-name-group">
                        <label>Output File Name:</label>
                        <input type="text" class="output-name-input" 
                               value="${file.name.replace(/\.[^/.]+$/, '')}"
                               placeholder="Enter converted file name"
                               id="outputName_${index}">
                    </div>
                    <div class="file-status status-ready" id="fileStatus_${index}">
                        <i class="fas fa-check-circle"></i>
                        Ready for conversion
                    </div>
                    <div class="file-points-count" id="pointsCount_${index}"></div>
                </div>
            `).join('');
        }

        function removeFile(index) {
            uploadedFiles.splice(index, 1);
            delete fileDataMap[`file_${index}`];
            displayFileCards();
            
            if (uploadedFiles.length === 0) {
                document.getElementById('resultsSection').style.display = 'none';
                document.getElementById('previewSection').style.display = 'none';
            }
        }

        function showStatus(message, type = 'success') {
            const statusDiv = document.getElementById('status');
            const iconClass = type === 'success' ? 'fa-check-circle' : 
                             type === 'error' ? 'fa-exclamation-circle' : 'fa-info-circle';
            
            statusDiv.innerHTML = `
                <div class="status ${type} fade-in">
                    <i class="fas ${iconClass}"></i>
                    ${message}
                </div>
            `;
            
            setTimeout(() => statusDiv.innerHTML = '', 5000);
        }

        function updateFileStatus(index, status, message, pointsCount = null) {
            const statusElement = document.getElementById(`fileStatus_${index}`);
            const pointsElement = document.getElementById(`pointsCount_${index}`);
            
            if (statusElement) {
                const iconClass = status === 'completed' ? 'fa-check-circle' :
                                 status === 'processing' ? 'fa-spinner fa-spin' :
                                 status === 'error' ? 'fa-exclamation-circle' : 'fa-check-circle';
                
                statusElement.className = `file-status status-${status}`;
                statusElement.innerHTML = `<i class="fas ${iconClass}"></i> ${message}`;
            }
            
            if (pointsElement && pointsCount !== null) {
                pointsElement.innerHTML = `<i class="fas fa-map-pin"></i> Points: ${pointsCount}`;
            }
        }

        function updateGlobalProgress(current, total, message) {
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            const progressContainer = document.getElementById('progressContainer');
            
            if (total > 1) {
                progressContainer.style.display = 'block';
                const percentage = (current / total) * 100;
                progressFill.style.width = `${percentage}%`;
                progressText.textContent = `${message} (${current}/${total})`;
            } else {
                progressContainer.style.display = 'none';
            }
        }

        async function parseSPSFile(file, index) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const content = e.target.result;
                        const lines = content.split('\n');
                        const points = [];

                        lines.forEach((line) => {
                            if (line.trim() && (line.startsWith('S') || line.startsWith('R'))) {
                                const parts = line.trim().split(/\s+/);
                                if (parts.length >= 7) {
                                    const easting = parseFloat(parts[4]);
                                    const northing = parseFloat(parts[5]);
                                    const elevation = parseFloat(parts[6]);
                                    
                                    if (!isNaN(easting) && !isNaN(northing) && !isNaN(elevation)) {
                                        points.push({
                                            type: parts[0],
                                            line: parseFloat(parts[1]) || 0,
                                            point: parseFloat(parts[2]) || 0,
                                            index: parseInt(parts[3]) || 0,
                                            easting: easting,
                                            northing: northing,
                                            elevation: elevation,
                                            filename: file.name
                                        });
                                    }
                                }
                            }
                        });

                        updateFileStatus(index, 'completed', 'File parsed successfully', points.length);
                        resolve(points);
                    } catch (error) {
                        updateFileStatus(index, 'error', `Parse error: ${error.message}`);
                        reject(error);
                    }
                };
                reader.onerror = () => {
                    const errorMsg = 'Failed to read file';
                    updateFileStatus(index, 'error', errorMsg);
                    reject(new Error(errorMsg));
                };
                reader.readAsText(file);
            });
        }

        function convertUTMToLatLon(easting, northing, zone, datum) {
            const utmProj = `+proj=utm +zone=${zone} +datum=${datum} +units=m +no_defs`;
            const wgs84Proj = projDefs[datum];
            
            try {
                const result = proj4(utmProj, wgs84Proj, [easting, northing]);
                return { lon: result[0], lat: result[1] };
            } catch (error) {
                console.error('Projection error:', error);
                return { lon: easting, lat: northing };
            }
        }

        function generateCSV(data) {
            const headers = ['Type', 'Line', 'Point', 'Index', 'Easting', 'Northing', 'Elevation', 'Longitude', 'Latitude'];
            const csvContent = [
                headers.join(','),
                ...data.map(point => [
                    point.type, point.line, point.point, point.index,
                    point.easting, point.northing, point.elevation,
                    point.longitude, point.latitude
                ].join(','))
            ].join('\n');

            return new Blob([csvContent], { type: 'text/csv;charset=utf-8' });
        }

        function generateGeoJSON(data) {
            const features = data.map(point => ({
                type: 'Feature',
                geometry: {
                    type: 'Point',
                    coordinates: [point.longitude, point.latitude, point.elevation]
                },
                properties: {
                    type: point.type,
                    line: point.line,
                    point: point.point,
                    index: point.index,
                    easting: point.easting,
                    northing: point.northing,
                    elevation: point.elevation
                }
            }));

            const geojson = {
                type: 'FeatureCollection',
                features: features
            };

            return new Blob([JSON.stringify(geojson, null, 2)], { type: 'application/json' });
        }

        function generateKML(data) {
            let kml = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>SPS Points</name>
    <description>Converted SPS Point Records</description>
    <Style id="shotpoint">
      <IconStyle>
        <Icon>
          <href>http://maps.google.com/mapfiles/kml/shapes/placemark_circle.png</href>
        </Icon>
      </IconStyle>
    </Style>
    <Style id="receiver">
      <IconStyle>
        <Icon>
          <href>http://maps.google.com/mapfiles/kml/shapes/placemark_square.png</href>
        </Icon>
      </IconStyle>
    </Style>`;

            data.forEach(point => {
                kml += `
    <Placemark>
      <name>${point.type}-${point.line}-${point.point}</name>
      <description>
        Type: ${point.type}
        Line: ${point.line}
        Point: ${point.point}
        Index: ${point.index}
        UTM Easting: ${point.easting}
        UTM Northing: ${point.northing}
        Elevation: ${point.elevation}
      </description>
      <styleUrl>#${point.type === 'S' ? 'shotpoint' : 'receiver'}</styleUrl>
      <Point>
        <coordinates>${point.longitude},${point.latitude},${point.elevation}</coordinates>
      </Point>
    </Placemark>`;
            });

            kml += `
  </Document>
</kml>`;

            return new Blob([kml], { type: 'application/vnd.google-earth.kml+xml' });
        }

        // WKT definitions for common coordinate systems
        const wktDefinitions = {
            'WGS84': {
                geographic: 'GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]]',
                utm: {
                    32: 'PROJCS["WGS_1984_UTM_Zone_32N",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",9.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]',
                    33: 'PROJCS["WGS_1984_UTM_Zone_33N",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",15.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]',
                    34: 'PROJCS["WGS_1984_UTM_Zone_34N",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",21.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]',
                    35: 'PROJCS["WGS_1984_UTM_Zone_35N",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",27.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]',
                    36: 'PROJCS["WGS_1984_UTM_Zone_36N",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",33.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]',
                    37: 'PROJCS["WGS_1984_UTM_Zone_37N",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",39.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]',
                    38: 'PROJCS["WGS_1984_UTM_Zone_38N",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",45.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]',
                    39: 'PROJCS["WGS_1984_UTM_Zone_39N",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",51.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]'
                }
            },
            'ED50': {
                geographic: 'GEOGCS["GCS_European_Datum_1950",DATUM["D_European_Datum_1950",SPHEROID["International_1924",6378388.0,297.0]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]]',
                utm: {
                    32: 'PROJCS["ED_1950_UTM_Zone_32N",GEOGCS["GCS_European_Datum_1950",DATUM["D_European_Datum_1950",SPHEROID["International_1924",6378388.0,297.0]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",9.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]',
                    33: 'PROJCS["ED_1950_UTM_Zone_33N",GEOGCS["GCS_European_Datum_1950",DATUM["D_European_Datum_1950",SPHEROID["International_1924",6378388.0,297.0]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",15.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]',
                    34: 'PROJCS["ED_1950_UTM_Zone_34N",GEOGCS["GCS_European_Datum_1950",DATUM["D_European_Datum_1950",SPHEROID["International_1924",6378388.0,297.0]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",21.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]',
                    35: 'PROJCS["ED_1950_UTM_Zone_35N",GEOGCS["GCS_European_Datum_1950",DATUM["D_European_Datum_1950",SPHEROID["International_1924",6378388.0,297.0]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",27.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]',
                    36: 'PROJCS["ED_1950_UTM_Zone_36N",GEOGCS["GCS_European_Datum_1950",DATUM["D_European_Datum_1950",SPHEROID["International_1924",6378388.0,297.0]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",33.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]',
                    37: 'PROJCS["ED_1950_UTM_Zone_37N",GEOGCS["GCS_European_Datum_1950",DATUM["D_European_Datum_1950",SPHEROID["International_1924",6378388.0,297.0]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",39.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]',
                    38: 'PROJCS["ED_1950_UTM_Zone_38N",GEOGCS["GCS_European_Datum_1950",DATUM["D_European_Datum_1950",SPHEROID["International_1924",6378388.0,297.0]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",45.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]',
                    39: 'PROJCS["ED_1950_UTM_Zone_39N",GEOGCS["GCS_European_Datum_1950",DATUM["D_European_Datum_1950",SPHEROID["International_1924",6378388.0,297.0]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",51.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]'
                }
            },
            'NAD83': {
                geographic: 'GEOGCS["GCS_North_American_1983",DATUM["D_North_American_1983",SPHEROID["GRS_1980",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]]',
                utm: {
                    32: 'PROJCS["NAD_1983_UTM_Zone_32N",GEOGCS["GCS_North_American_1983",DATUM["D_North_American_1983",SPHEROID["GRS_1980",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",9.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]',
                    33: 'PROJCS["NAD_1983_UTM_Zone_33N",GEOGCS["GCS_North_American_1983",DATUM["D_North_American_1983",SPHEROID["GRS_1980",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",15.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]',
                    34: 'PROJCS["NAD_1983_UTM_Zone_34N",GEOGCS["GCS_North_American_1983",DATUM["D_North_American_1983",SPHEROID["GRS_1980",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",21.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]',
                    35: 'PROJCS["NAD_1983_UTM_Zone_35N",GEOGCS["GCS_North_American_1983",DATUM["D_North_American_1983",SPHEROID["GRS_1980",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",27.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]',
                    36: 'PROJCS["NAD_1983_UTM_Zone_36N",GEOGCS["GCS_North_American_1983",DATUM["D_North_American_1983",SPHEROID["GRS_1980",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",33.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]',
                    37: 'PROJCS["NAD_1983_UTM_Zone_37N",GEOGCS["GCS_North_American_1983",DATUM["D_North_American_1983",SPHEROID["GRS_1980",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",39.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]',
                    38: 'PROJCS["NAD_1983_UTM_Zone_38N",GEOGCS["GCS_North_American_1983",DATUM["D_North_American_1983",SPHEROID["GRS_1980",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",45.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]',
                    39: 'PROJCS["NAD_1983_UTM_Zone_39N",GEOGCS["GCS_North_American_1983",DATUM["D_North_American_1983",SPHEROID["GRS_1980",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",51.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]'
                }
            }
        };

        // Function to get the appropriate WKT string based on coordinate system settings
        function getWKTString(datum, utmZone) {
            // For geographic (lat/lon) output, use geographic WKT
            return wktDefinitions[datum].geographic;
            
            // If we were to use UTM coordinates in the shapefile, we would use:
            // return wktDefinitions[datum].utm[utmZone];
        }

        // Improved Shapefile generation function
        async function generateShapefile(data, datum = 'WGS84', utmZone = 32) {
            const zip = new JSZip();
            
            // Generate proper .prj file with correct WKT
            const prjContent = getWKTString(datum, utmZone);
            zip.file('points.prj', prjContent);
            
            // Generate proper .shp file
            const shpContent = generateSHPContent(data);
            zip.file('points.shp', shpContent);
            
            // Generate proper .shx file
            const shxContent = generateSHXContent(data);
            zip.file('points.shx', shxContent);
            
            // Generate proper .dbf file
            const dbfContent = generateDBFContent(data);
            zip.file('points.dbf', dbfContent);
            
            return await zip.generateAsync({ type: 'blob' });
        }

        // Improved .shp file generation
        function generateSHPContent(data) {
            // Calculate file size: header (100 bytes) + records
            // Each point record: 8 bytes (record header) + 4 bytes (shape type) + 16 bytes (X,Y coordinates) = 28 bytes
            const recordSize = 28;
            const totalFileSize = 100 + (data.length * recordSize);
            const fileLengthInWords = totalFileSize / 2; // File length is in 16-bit words
            
            // Calculate bounding box
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            data.forEach(point => {
                minX = Math.min(minX, point.longitude);
                minY = Math.min(minY, point.latitude);
                maxX = Math.max(maxX, point.longitude);
                maxY = Math.max(maxY, point.latitude);
            });
            
            // Create the complete .shp file
            const buffer = new ArrayBuffer(totalFileSize);
            const view = new DataView(buffer);
            
            // File Header (100 bytes)
            view.setUint32(0, 9994, false);           // File code (big-endian)
            view.setUint32(4, 0, false);             // Unused
            view.setUint32(8, 0, false);             // Unused
            view.setUint32(12, 0, false);            // Unused
            view.setUint32(16, 0, false);            // Unused
            view.setUint32(20, 0, false);            // Unused
            view.setUint32(24, fileLengthInWords, false); // File length in 16-bit words (big-endian)
            view.setUint32(28, 1000, true);          // Version (little-endian)
            view.setUint32(32, 1, true);             // Shape type: Point (little-endian)
            view.setFloat64(36, minX, true);         // Bounding box Xmin (little-endian)
            view.setFloat64(44, minY, true);         // Bounding box Ymin (little-endian)
            view.setFloat64(52, maxX, true);         // Bounding box Xmax (little-endian)
            view.setFloat64(60, maxY, true);         // Bounding box Ymax (little-endian)
            view.setFloat64(68, 0, true);            // Bounding box Zmin (little-endian)
            view.setFloat64(76, 0, true);            // Bounding box Zmax (little-endian)
            view.setFloat64(84, 0, true);            // Bounding box Mmin (little-endian)
            view.setFloat64(92, 0, true);            // Bounding box Mmax (little-endian)
            
            // Records
            let offset = 100;
            data.forEach((point, index) => {
                // Record header (8 bytes)
                view.setUint32(offset, index + 1, false);     // Record number (big-endian, 1-based)
                view.setUint32(offset + 4, 10, false);        // Content length in 16-bit words (big-endian)
                
                // Record content (20 bytes)
                view.setUint32(offset + 8, 1, true);          // Shape type: Point (little-endian)
                view.setFloat64(offset + 12, point.longitude, true); // X coordinate (little-endian)
                view.setFloat64(offset + 20, point.latitude, true);  // Y coordinate (little-endian)
                
                offset += recordSize;
            });
            
            return new Blob([buffer], { type: 'application/octet-stream' });
        }

        // Improved .shx file generation
        function generateSHXContent(data) {
            // .shx file: header (100 bytes) + index records (8 bytes each)
            const indexRecordSize = 8;
            const totalFileSize = 100 + (data.length * indexRecordSize);
            const fileLengthInWords = totalFileSize / 2;
            
            // Calculate bounding box (same as .shp)
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            data.forEach(point => {
                minX = Math.min(minX, point.longitude);
                minY = Math.min(minY, point.latitude);
                maxX = Math.max(maxX, point.longitude);
                maxY = Math.max(maxY, point.latitude);
            });
            
            const buffer = new ArrayBuffer(totalFileSize);
            const view = new DataView(buffer);
            
            // File Header (identical to .shp header)
            view.setUint32(0, 9994, false);           // File code (big-endian)
            view.setUint32(4, 0, false);             // Unused
            view.setUint32(8, 0, false);             // Unused
            view.setUint32(12, 0, false);            // Unused
            view.setUint32(16, 0, false);            // Unused
            view.setUint32(20, 0, false);            // Unused
            view.setUint32(24, fileLengthInWords, false); // File length in 16-bit words (big-endian)
            view.setUint32(28, 1000, true);          // Version (little-endian)
            view.setUint32(32, 1, true);             // Shape type: Point (little-endian)
            view.setFloat64(36, minX, true);         // Bounding box Xmin (little-endian)
            view.setFloat64(44, minY, true);         // Bounding box Ymin (little-endian)
            view.setFloat64(52, maxX, true);         // Bounding box Xmax (little-endian)
            view.setFloat64(60, maxY, true);         // Bounding box Ymax (little-endian)
            view.setFloat64(68, 0, true);            // Bounding box Zmin (little-endian)
            view.setFloat64(76, 0, true);            // Bounding box Zmax (little-endian)
            view.setFloat64(84, 0, true);            // Bounding box Mmin (little-endian)
            view.setFloat64(92, 0, true);            // Bounding box Mmax (little-endian)
            
            // Index records
            let offset = 100;
            let shpRecordOffset = 50; // Start after .shp header (100 bytes = 50 16-bit words)
            
            data.forEach((point, index) => {
                // Each index record: 4 bytes offset + 4 bytes content length
                view.setUint32(offset, shpRecordOffset, false);     // Offset in .shp file (big-endian, in 16-bit words)
                view.setUint32(offset + 4, 10, false);             // Content length (big-endian, in 16-bit words)
                
                offset += indexRecordSize;
                shpRecordOffset += 14; // Each .shp record is 28 bytes = 14 16-bit words
            });
            
            return new Blob([buffer], { type: 'application/octet-stream' });
        }

        // Improved .dbf file generation
        function generateDBFContent(data) {
            // DBF structure: header + field descriptors + records
            const fieldCount = 8; // Type, Line, Point, Index, Easting, Northing, Elevation, Filename
            const headerSize = 32 + (fieldCount * 32) + 1; // 32-byte header + field descriptors + terminator
            const recordSize = 1 + 1 + 10 + 10 + 10 + 15 + 15 + 15 + 50; // Deletion flag + field sizes
            const totalFileSize = headerSize + (data.length * recordSize);
            
            const buffer = new ArrayBuffer(totalFileSize);
            const view = new DataView(buffer);
            const textEncoder = new TextEncoder();
            
            // DBF Header (32 bytes)
            view.setUint8(0, 0x03);                    // Version
            view.setUint8(1, 25);                      // Last update year (2025 - 1900)
            view.setUint8(2, 1);                       // Last update month
            view.setUint8(3, 1);                       // Last update day
            view.setUint32(4, data.length, true);     // Number of records (little-endian)
            view.setUint16(8, headerSize, true);      // Header size (little-endian)
            view.setUint16(10, recordSize, true);     // Record size (little-endian)
            // Bytes 12-31 are reserved/unused
            
            // Field Descriptors (32 bytes each)
            let fieldOffset = 32;
            
            // Field 1: Type (Character, 1 byte)
            const typeField = textEncoder.encode('TYPE');
            for (let i = 0; i < typeField.length; i++) {
                view.setUint8(fieldOffset + i, typeField[i]);
            }
            view.setUint8(fieldOffset + 11, 0x43); // 'C' for Character
            view.setUint8(fieldOffset + 16, 1);    // Field length
            fieldOffset += 32;
            
            // Field 2: Line (Numeric, 10 bytes)
            const lineField = textEncoder.encode('LINE');
            for (let i = 0; i < lineField.length; i++) {
                view.setUint8(fieldOffset + i, lineField[i]);
            }
            view.setUint8(fieldOffset + 11, 0x4E); // 'N' for Numeric
            view.setUint8(fieldOffset + 16, 10);   // Field length
            fieldOffset += 32;
            
            // Field 3: Point (Numeric, 10 bytes)
            const pointField = textEncoder.encode('POINT');
            for (let i = 0; i < pointField.length; i++) {
                view.setUint8(fieldOffset + i, pointField[i]);
            }
            view.setUint8(fieldOffset + 11, 0x4E); // 'N' for Numeric
            view.setUint8(fieldOffset + 16, 10);   // Field length
            fieldOffset += 32;
            
            // Field 4: Index (Numeric, 10 bytes)
            const indexField = textEncoder.encode('INDEX');
            for (let i = 0; i < indexField.length; i++) {
                view.setUint8(fieldOffset + i, indexField[i]);
            }
            view.setUint8(fieldOffset + 11, 0x4E); // 'N' for Numeric
            view.setUint8(fieldOffset + 16, 10);   // Field length
            fieldOffset += 32;
            
            // Field 5: Easting (Numeric, 15 bytes, 3 decimal places)
            const eastingField = textEncoder.encode('EASTING');
            for (let i = 0; i < eastingField.length; i++) {
                view.setUint8(fieldOffset + i, eastingField[i]);
            }
            view.setUint8(fieldOffset + 11, 0x4E); // 'N' for Numeric
            view.setUint8(fieldOffset + 16, 15);   // Field length
            view.setUint8(fieldOffset + 17, 3);    // Decimal places
            fieldOffset += 32;
            
            // Field 6: Northing (Numeric, 15 bytes, 3 decimal places)
            const northingField = textEncoder.encode('NORTHING');
            for (let i = 0; i < northingField.length; i++) {
                view.setUint8(fieldOffset + i, northingField[i]);
            }
            view.setUint8(fieldOffset + 11, 0x4E); // 'N' for Numeric
            view.setUint8(fieldOffset + 16, 15);   // Field length
            view.setUint8(fieldOffset + 17, 3);    // Decimal places
            fieldOffset += 32;
            
            // Field 7: Elevation (Numeric, 15 bytes, 3 decimal places)
            const elevationField = textEncoder.encode('ELEVATION');
            for (let i = 0; i < elevationField.length; i++) {
                view.setUint8(fieldOffset + i, elevationField[i]);
            }
            view.setUint8(fieldOffset + 11, 0x4E); // 'N' for Numeric
            view.setUint8(fieldOffset + 16, 15);   // Field length
            view.setUint8(fieldOffset + 17, 3);    // Decimal places
            fieldOffset += 32;
            
            // Field 8: Filename (Character, 50 bytes)
            const filenameField = textEncoder.encode('FILENAME');
            for (let i = 0; i < filenameField.length; i++) {
                view.setUint8(fieldOffset + i, filenameField[i]);
            }
            view.setUint8(fieldOffset + 11, 0x43); // 'C' for Character
            view.setUint8(fieldOffset + 16, 50);   // Field length
            fieldOffset += 32;
            
            // Field descriptor terminator
            view.setUint8(fieldOffset, 0x0D);
            fieldOffset += 1;
            
            // Records
            data.forEach((point, index) => {
                let recordOffset = fieldOffset + (index * recordSize);
                
                // Deletion flag (not deleted)
                view.setUint8(recordOffset, 0x20); // Space character
                recordOffset += 1;
                
                // Type field (1 byte)
                view.setUint8(recordOffset, point.type.charCodeAt(0));
                recordOffset += 1;
                
                // Line field (10 bytes, right-aligned)
                const lineStr = point.line.toString().padStart(10, ' ');
                const lineBytes = textEncoder.encode(lineStr);
                for (let i = 0; i < 10; i++) {
                    view.setUint8(recordOffset + i, i < lineBytes.length ? lineBytes[i] : 32); // Space padding
                }
                recordOffset += 10;
                
                // Point field (10 bytes, right-aligned)
                const pointStr = point.point.toString().padStart(10, ' ');
                const pointBytes = textEncoder.encode(pointStr);
                for (let i = 0; i < 10; i++) {
                    view.setUint8(recordOffset + i, i < pointBytes.length ? pointBytes[i] : 32);
                }
                recordOffset += 10;
                
                // Index field (10 bytes, right-aligned)
                const indexStr = point.index.toString().padStart(10, ' ');
                const indexBytes = textEncoder.encode(indexStr);
                for (let i = 0; i < 10; i++) {
                    view.setUint8(recordOffset + i, i < indexBytes.length ? indexBytes[i] : 32);
                }
                recordOffset += 10;
                
                // Easting field (15 bytes, right-aligned, 3 decimal places)
                const eastingStr = point.easting.toFixed(3).padStart(15, ' ');
                const eastingBytes = textEncoder.encode(eastingStr);
                for (let i = 0; i < 15; i++) {
                    view.setUint8(recordOffset + i, i < eastingBytes.length ? eastingBytes[i] : 32);
                }
                recordOffset += 15;
                
                // Northing field (15 bytes, right-aligned, 3 decimal places)
                const northingStr = point.northing.toFixed(3).padStart(15, ' ');
                const northingBytes = textEncoder.encode(northingStr);
                for (let i = 0; i < 15; i++) {
                    view.setUint8(recordOffset + i, i < northingBytes.length ? northingBytes[i] : 32);
                }
                recordOffset += 15;
                
                // Elevation field (15 bytes, right-aligned, 3 decimal places)
                const elevationStr = point.elevation.toFixed(3).padStart(15, ' ');
                const elevationBytes = textEncoder.encode(elevationStr);
                for (let i = 0; i < 15; i++) {
                    view.setUint8(recordOffset + i, i < elevationBytes.length ? elevationBytes[i] : 32);
                }
                recordOffset += 15;
                
                // Filename field (50 bytes, left-aligned)
                const filename = point.filename || '';
                const filenameStr = filename.padEnd(50, ' ');
                const filenameBytes = textEncoder.encode(filenameStr);
                for (let i = 0; i < 50; i++) {
                    view.setUint8(recordOffset + i, i < filenameBytes.length ? filenameBytes[i] : 32);
                }
                recordOffset += 50;
            });
            
            return new Blob([buffer], { type: 'application/octet-stream' });
        }

        async function convertFiles() {
            if (uploadedFiles.length === 0) {
                showStatus('Please upload at least one file', 'error');
                return;
            }

            const convertBtn = document.getElementById('convertBtn');
            convertBtn.disabled = true;
            convertBtn.classList.add('processing');
            convertBtn.innerHTML = '<span class="loading-spinner"></span> Converting...';

            try {
                const utmZone = document.getElementById('utmZone').value;
                const datum = document.getElementById('datum').value;
                
                fileDataMap = {};
                let totalPoints = 0;
                let allPreviewData = [];

                // Process each file
                for (let i = 0; i < uploadedFiles.length; i++) {
                    const file = uploadedFiles[i];
                    updateGlobalProgress(i + 1, uploadedFiles.length, 'Processing files');
                    updateFileStatus(i, 'processing', 'Processing...');

                    try {
                        const points = await parseSPSFile(file, i);
                        
                        // Convert coordinates
                        points.forEach(point => {
                            const latLon = convertUTMToLatLon(point.easting, point.northing, utmZone, datum);
                            point.longitude = latLon.lon;
                            point.latitude = latLon.lat;
                        });

                        const fileKey = `file_${i}`;
                        fileDataMap[fileKey] = {
                            originalFile: file,
                            points: points,
                            outputName: document.getElementById(`outputName_${i}`).value || file.name.replace(/\.[^/.]+$/, ''),
                            index: i
                        };

                        totalPoints += points.length;
                        allPreviewData.push(...points.slice(0, 3)); // Add first 3 points from each file to preview
                        
                        updateFileStatus(i, 'completed', 'Conversion successful', points.length);
                    } catch (error) {
                        updateFileStatus(i, 'error', `Error: ${error.message}`);
                        console.error(`Error processing file ${file.name}:`, error);
                    }
                }

                updateGlobalProgress(uploadedFiles.length, uploadedFiles.length, 'Conversion complete');

                showStatus(`Successfully converted ${Object.keys(fileDataMap).length} files with ${totalPoints} total points!`);
                
                // Show preview if enabled
                if (document.getElementById('showPreview').checked && allPreviewData.length > 0) {
                    showPreview(allPreviewData);
                }

                // Generate downloads for each file
                await generateAllDownloads();
                
                document.getElementById('resultsSection').style.display = 'block';
                document.getElementById('resultsSection').classList.add('fade-in');

                // Hide progress after completion
                setTimeout(() => {
                    document.getElementById('progressContainer').style.display = 'none';
                }, 2000);

            } catch (error) {
                console.error('Conversion error:', error);
                showStatus(`Error during conversion: ${error.message}`, 'error');
            } finally {
                convertBtn.disabled = false;
                convertBtn.classList.remove('processing');
                convertBtn.innerHTML = '<i class="fas fa-rocket"></i> Convert Files';
            }
        }

        function showPreview(data) {
            const previewSection = document.getElementById('previewSection');
            const previewContent = document.getElementById('previewContent');
            
            let html = `<p>Data Preview (showing ${data.length} points out of ${Object.values(fileDataMap).reduce((sum, file) => sum + file.points.length, 0)} total points):</p>`;
            html += '<table class="preview-table">';
            html += '<tr><th>Type</th><th>Line</th><th>Point</th><th>Easting</th><th>Northing</th><th>Longitude</th><th>Latitude</th><th>File</th></tr>';
            
            data.forEach(point => {
                html += `<tr>
                    <td>${point.type}</td>
                    <td>${point.line}</td>
                    <td>${point.point}</td>
                    <td>${point.easting.toFixed(2)}</td>
                    <td>${point.northing.toFixed(2)}</td>
                    <td>${point.longitude.toFixed(6)}</td>
                    <td>${point.latitude.toFixed(6)}</td>
                    <td>${point.filename}</td>
                </tr>`;
            });
            
            html += '</table>';
            previewContent.innerHTML = html;
            previewSection.style.display = 'block';
            previewSection.classList.add('fade-in');
        }

        async function generateAllDownloads() {
            const fileResultsGrid = document.getElementById('fileResultsGrid');
            fileResultsGrid.innerHTML = '';

            const zipAllFiles = document.getElementById('zipAllFiles').checked;
            let allFilesZip = null;
            
            if (zipAllFiles) {
                allFilesZip = new JSZip();
            }

            for (const [fileKey, fileData] of Object.entries(fileDataMap)) {
                const { points, outputName, originalFile } = fileData;
                
                let downloadHtml = `
                    <div class="file-result-card">
                        <div class="file-result-header">
                            <i class="fas fa-file-alt"></i>
                            ${originalFile.name}
                            <br><small>Output Name: ${outputName}</small>
                            <br><small>Points: ${points.length}</small>
                        </div>
                        <div class="download-grid">`;

                // Generate individual format files
                if (document.getElementById('exportCSV').checked) {
                    const csvBlob = generateCSV(points);
                    const csvUrl = URL.createObjectURL(csvBlob);
                    const csvFileName = `${outputName}.csv`;
                    downloadHtml += `<a href="${csvUrl}" download="${csvFileName}" class="download-btn">
                        <i class="fas fa-table"></i> CSV
                    </a>`;
                    
                    if (zipAllFiles) allFilesZip.file(csvFileName, csvBlob);
                }

                if (document.getElementById('exportGeoJSON').checked) {
                    const geojsonBlob = generateGeoJSON(points);
                    const geojsonUrl = URL.createObjectURL(geojsonBlob);
                    const geojsonFileName = `${outputName}.geojson`;
                    downloadHtml += `<a href="${geojsonUrl}" download="${geojsonFileName}" class="download-btn">
                        <i class="fas fa-map"></i> GeoJSON
                    </a>`;
                    
                    if (zipAllFiles) allFilesZip.file(geojsonFileName, geojsonBlob);
                }

                if (document.getElementById('exportKML').checked) {
                    const kmlBlob = generateKML(points);
                    const kmlUrl = URL.createObjectURL(kmlBlob);
                    const kmlFileName = `${outputName}.kml`;
                    downloadHtml += `<a href="${kmlUrl}" download="${kmlFileName}" class="download-btn">
                        <i class="fas fa-globe"></i> KML
                    </a>`;
                    
                    if (zipAllFiles) allFilesZip.file(kmlFileName, kmlBlob);
                }

                if (document.getElementById('exportShapefile').checked) {
                    const utmZone = parseInt(document.getElementById('utmZone').value);
                    const datum = document.getElementById('datum').value;
                    const shapefileBlob = await generateShapefile(points, datum, utmZone);
                    const shapefileUrl = URL.createObjectURL(shapefileBlob);
                    const shapefileName = `${outputName}_shapefile.zip`;
                    downloadHtml += `<a href="${shapefileUrl}" download="${shapefileName}" class="download-btn">
                        <i class="fas fa-layer-group"></i> Shapefile
                    </a>`;
                    
                    if (zipAllFiles) allFilesZip.file(shapefileName, shapefileBlob);
                }

                downloadHtml += '</div></div>';
                fileResultsGrid.innerHTML += downloadHtml;
            }

            // Add download all option if enabled
            if (zipAllFiles && allFilesZip) {
                const allFilesBlob = await allFilesZip.generateAsync({ type: 'blob' });
                const allFilesUrl = URL.createObjectURL(allFilesBlob);
                
                fileResultsGrid.innerHTML += `
                    <div class="file-result-card" style="border: 2px solid var(--success-color);">
                        <div class="file-result-header" style="color: var(--success-color);">
                            <i class="fas fa-download"></i>
                            Download All Files
                            <br><small>Archive containing all converted files</small>
                        </div>
                        <div class="download-grid">
                            <a href="${allFilesUrl}" download="all_converted_files.zip" 
                               class="download-btn download-all-btn">
                               <i class="fas fa-cloud-download-alt"></i> Download All
                            </a>
                        </div>
                    </div>`;
            }
        }

        // Cleanup URLs when page unloads to prevent memory leaks
        window.addEventListener('beforeunload', () => {
            document.querySelectorAll('a[href^="blob:"]').forEach(link => {
                URL.revokeObjectURL(link.href);
            });
        });
    </script>
</body>
</html>

